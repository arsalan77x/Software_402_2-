# Software Engineering Lab
## آزمایش اول - مدیریت نسخ پروژه و یک‌پارچه‌سازی و استقرار مستمر

<br><br>
___

### روال انجام آزمایش
در این پروژه یک نرم‌افزار static frontend را به‌صورت pure پیاده‌سازی و سپس با کمک Github Actions  این نرم‌افزار static خود را به‌صورت خودکار، روی Github Pages مستقر (deploy) کرده‌ایم. تصویر زیر خروجی کار را نشان می‌دهد.
<br><br>
![alt text](/readme_resouce/readme1.png)
<br><br>
___

### پیش‌برد روند پروژه

ابتدا مخزن گیت‌هاب توسط PO ساخته شد و سپس دو عضو دیگر که developer هستند به مخزن اضافه شدند.همچنین مطابق تصویر زیر در تنظیمات مخزن، شاخه‌ی main را روی حالت protected تنظیم کرده تا بدون pull request تغییری صورت نگیرد.
<br><br>
![alt text](/readme_resouce/readme2.png)
<br><br>
در ادامه PO یک پروژه‌ی Kanban ساخته و task های پروژه را تعریف کرد که در تصویر زیر قابل مشاهده است.
![alt text](/readme_resouce/readme3.png)
<br><br>

مطابق user-story های تعریف شده دو شاخه‌ی اصلی برای محتوا و استایل ساخته شد که چون در صورت گزارش اشاره‌ای به issue کردن تسک ها در kanban نشده بود علاوه بر 7 تسک تعریف شده این دو شاخه را نیز به kanban اضافه کردیم که در نهایت به وضعیت done در آمد که در شکل زیر قابل مشاهده است. 
<br><br>
![alt text](/readme_resouce/readme4.png)
<br><br>

بعد از تمام شدن کار هر شاخه نیاز به pull request بود که دو تصویر زیر حالت آن در قبل و پس از review نشان می‌دهد. همانطور که مشخص است شخص مرور کننده کامیت هارا بررسی  و آن‌هارا approve تا با شاخه‌ی اصلی ادغام شود. 
در این مرحله ابتدا تسک‌ها به حالت review در kanban در می‌آمدند.
<br><br>
![alt text](/readme_resouce/readme5.png)
![alt text](/readme_resouce/readme6.png)
![alt text](/readme_resouce/readme7.png)
<br><br>

### حل کانفلیکت‌ها
1. کانفلیکت اول: <br>
این کانفلیکت از جنس تغییر همزمان در  یک خط بود  که هر دو دولوپر روی بخش about کار می‌کردند و یکی از آن‌ها Inline-style هم در نظر گرفته بود ولی دیرتر پوش کرده و نیاز بود تا اول pull کند. برای رفع این conflict باید مرج کرد و کد فعلی را جایگزین کرد. این دقیقا برعکس اتفاق کانفلیکت دوم است که جلوتر توضیح داده می‌شود.
<br><br>
![alt text](/readme_resouce/readme8.png)
![alt text](/readme_resouce/readme9.png)
<br><br>
2. کانفلیکت دوم: <br>
مانند بخش قبل یک بخش را دو نفر ویرایش کردند با این تفاوت که کسی که به کانفلیکت خورد کد پوش شده را میپذیرد پس غیر از merge راهکار دیگر این بود که اول Pull کند. همانطور که در تصویر قابل مشاهده است، تغییر قابل مشاهده با عمل pull اینطور  گزارش شده پس این کانفلیکت را با pull کردن برطرف کردیم و دیگر نیازی به پوش نبود چون این نسخه کامل‌تر بود.
![image](https://github.com/faraz1380/Software_402_2-/assets/63359673/5b232415-9ef1-485c-a7a7-bcee391fe647)

3. کانفلیکت سوم: 
این کانفلیکت در یک ریپازیتوری دیگر  رخ داد که چون روند برنچ‌ها به هم ریخته شد آن را ادامه ندادیم. علت کانفلیکت این بود که شاخه‌ای که از main برای Style جدا شده بود و در ابتدا pull نکرده بود و  طبیعتا برای پوش کردن نیاز به مرج داشت ولی به اشتباه push force انجام شد که نتیجه در تصویر قابل مشاهده است.
<br><br>
![alt text](/readme_resouce/readme10.png)
<br><br>
4. کانفلیکت چهارم: <br>
کانفلیکت بالا در این ریپازیتوری هم به وجود آمد که با merge مطابق تصویر با پاک کردن بخش اضافی به راحتی حل شد.
<br><br>
![image](https://github.com/faraz1380/Software_402_2-/assets/63359673/f22b1ef0-4d5b-4476-8ec1-a43c2883bd48)
![image](https://github.com/faraz1380/Software_402_2-/assets/63359673/1dc7c9f5-ec95-40e9-9de6-b785331a5ed4)
<br><br>

___

### پرسش‌ها

1. پوشه‌ی .git چیست؟ چه اطلاعاتی در آن ذخیره می‌شود؟ با چه دستوری ساخته می‌شود؟ <br><br>
پوشه‌ی .git یک پوشه‌ی مخفی است که فراداده (metadata) و object database مربوط به پروژه را در خود ذخیره می‌کند. این بخش مهم‌ترین عضو Git بوده و همان بخشی است که وقتی یک repository را clone می‌کنیم به کامپیوتر دیگری کپی می‌شود. اطلاعات مهمی اعم از شاخه‌ها (branches)، کامیت‌ها، پیکربندی و ... در آن ذخیره می‌شود که در ادامه به توضیح آن‌ها خواهیم پرداخت: <br>
   objects:  شامل تمام اشیاء Git مانند کامیت‌ها، درختان (trees) و بلاب‌ها (blobs) است. <br>
   refs:  شامل اشاره‌گرها به کامیت‌ها، از جمله اشاره‌گرها به شاخه‌ها و تگ‌ها. <br>
   HEAD:  فایلی که شاخه فعال فعلی را نشان می‌دهد. <br>
   config:  فایلی که تنظیمات مخزن را نگهداری می‌کند. <br>
   index:  فایلی که حالت فعلی فضای کاری (working directory) را ثبت می‌کند. <br>
 پوشه‌ی hooks: این پوشه حاوی فایل‌های اسکریپت است. Git hookها اسکریپت‌هایی هستند که قبل یا بعد از رویدادهایی مانند commit، push و غیره اجرا می‌شوند. <br>
این پوشه با دستور git init در root ایجاد می‌شود. زمانی که این دستور را اجرا می‌کنیم، پوشه‌ی جدیدی در دایرکتوری فعلی ساخته شده و پروژه آماده‌ی مدیریت با Git می‌شود.
<br><br>
***

2. منظور از atomic بودن در atomic commit و atomic pull-request چیست؟ <br><br>
Atomic Commit: تغییر یا مجموعه تغییراتی که به هم مربوطند و همچنین کاملند و نیاز به کامیت دیگری برای تکمیل ندارند. در واقع هر کامیت باید نشان‌دهنده‌ی یک عمل یا فیکس واحد باشد که در آینده خواستیم تاریخچه یا history تغییرات را بررسی کنیم راحت باشیم. وقتی از atomic بودن کامیت صحبت می‌کنیم منظور بیشتر این است که به کامیت دیگری وابستگی ندارد و به تنهایی کار میکند و تمام تست‌ها را پاس کرده و باعث خرابی نمی‌شود. البته لزومی ندارد که کامیت تعداد خط کدش کم باشد، مهم این است که از لحاظ منطقی کوچکترین عمل ممکن را انجام دهد. <br><br>
Atomic pull-request: به طور معمول بزرگتر از حالت قبل است چرا که اینجا با یک batch of changes طرف هستیم که یک فیچر خاص اضافه می‌کند، یک تسکی را انجام می‌دهد یا یک باگی را رفع می‌کند. با این‌که این عمل هم atomic هست و فقط یکی از موارد بالا را انجام می‌دهد ولی گسترده‌تر از
commit است و ممکن است چند کامیت را شامل شود. به طور معمول هم چون به یک هدف مشخصی می‌رسد میتوان با codebase تلفیق یا integrate شود.
<br><br>
به عنوان مثال اگر بخواهیم فیچر user profile ساده را به سایت اضافه کنیم این یک atomic pull request است که چند کامیت "add new route to page"، "create page template"، "fetch user data in backend را می‌تواند شامل شود.


<br><br><br><br>
***
3. تفاوت دستورهای fetch و pull و merge و rebase و cherry-pick را بیان کنید. <br><br>
Fetch: هدف دانلود بدون merge همه‌ی تغییرات در یک ریپازیتوری است. (مثلا یک ریپو در گیتهاب)  با این روش می‌توان فهمید بقیه چه کرده‌اند بدون اینکه تغییری integrate شود. <br>
Pull: مثل fetch فقط merge هم می‌شود. می‌توان در شاخه یا branch فعلی که روی آن کار می‌کنیم مرج کنیم. <br>
Merge: می‌شود گفت Fetch و Merge روی هم pull می‌شوند، پس در مرج صرفا می‌خواهم یک branch را در branch دیگری ادغام کنیم و هدف دانلود نیست. <br>
Rebase: وقتی می‌خواهیم یک سری کامیت (دنباله‌ی کامیت‌ها) را با یک base commit جدید ترکیب کنیم یا به آن انتقال دهیم از این دستور استفاده می‌کنیم. هدف ساده‌ سازی commit history است، بدین صورت که مثلا یک feature branch را به سر یک main branch می‌بریم. ارتباط این مورد با موارد قبل این است که از مرج‌های غیر ضروری جلوگیری می‌کند. <br>
Cherry-pick: به صورت انتخابی یک کامیت از یک شاخه یا branch را در شاخه‌ای دیگر می‌برد. برای وقتی که میخواهیم یک تغییر خاص را بدون بقیه‌ی تاریخچه‌ی آن شاخه استفاده کنیم. <br>
<br><br><br><br>
***

4. تفاوت دستورهای reset و revert و restore و switch و checkout را بیان کنید. <br> <br>
Git revert: این دستور این کار را می کند که تغییراتی که در commit قبلی ایجاد شده، برگشت بخورد (undo بشود) توجه کنید این دستور، یک history جدید به پروژه اضافه می کند. اگر در history مخزن، commit ای بوده که پشیمان شده اید و نامناسب می پندارید، می توانید از این دستور استفاده کنید تا تغییرات را undo کند و این را در history یادداشت می کند. <br> <br>
Git checkout: این دستور محتوای مخزن را check-out می کند و در درخت کاری اضافه می کند. این دستور، تغییراتی در history ایجاد نمی کند. همچنین، این دستور پتانسیل بیشتری هم بسته به کاربرد دارد، مثلا می تواند شاخه ای که در لحظه روی آن کار می کنید را جا به جا کند. دقت کنید این دستور نیز تنوع کاربردی زیادی دارد و "می تواند" در برخی موارد، کارش با git reset مشابه باشد هر چند تفاوت هایی هم دارند. مثلا در مقایسه دو دستور git reset --hard <path> و git checkout <path> این تفاوت را دارند که در reset گیت head را به یک commit دیگر جا به جا می کند ولی checkout اینجا به گیت نمی گوید که تغییری در head ایجاد کند. <br> <br>
Git reset: این دستور کمی گسترده و جامع است. مثلا می تواند index یا همان staging area را تغییر دهد. یا اینکه head ای که دارد به یک commit خاص از یک شاخه اشاره می کند را جا به جا کند. همچنین، با تغییر دادن commit ای که یک شاخه به آن اشاره می کند، می تواند history فعلی را هم تغییر دهد. کاربرد این وقتی است که مثلا شما commit ای کرده باشید ولی فعلا آن را با بقیه به اشتراک نگذاشته بودید (هنوز در سایت گیت به طور رسمی نیست) و پشیمان می شوید و کلا هم نمی خواید آن را به اشتراک بگذارید، آن وقت با این دستور شما می توانید history را تغییر دهید به گونه ای که انگار هیچ وقت آن commit را انجام نداده بودید. <br> <br>
Git restore: دقت کنید که قبلا دستور git checkout کاربرد داشت ولی زیادی پیچیده بود. برای راحتی کاربران، در سال 2019 این دستور git restore در ورژن Git 2.23 همراه با دوستش، git switch، روی کار آمدند. قضیه از این قرار است که دستورات متنوعی که با git checkout می توانید استفاده کنید، به دو بخش تقسیم می شوند و برای سادگی این دو دستور معرفی شدند. یکسری دستورات هستند که تغییرات commit نشده ی خود را در صورتی که بخواهید حذف شوند، برایتان حذف می کند. این دسته از دستورات در git restore جای دارد. همچنین، برای بازیابی فایل ها از یک commit مشخص نیز با همین git restore قابل انجام است. <br> <br>
Git switch: دسته ی دیگری از دستورات git checkout که تغییرات commit نشده ی شما را حذف نمی کنند، در دستور git switch جای دارد. همچنین، قابلیت پیشین git checkout که می توانست شاخه جدید بسازد و به آن بپرد، نیز، در همین git switch قرار داده شده. <br><br>

<br><br><br><br>
***
5. منظور از stage یا همان index چیست؟ دستور stash چه کاری را انجام می‌دهد؟<br> <br> در گیت، وقتی stage می کنیم، یعنی فایل هایمان را برای ذخیره سازی در commit آماده می کنیم. مثلا وقتی از دستور git add استفاده می کنیم، یعنی داریم stage می کنیم، به طور دقیق تر، با این کار، فایل های مدنظرمان در محیطی به نام stage ذخیره می شوند و آماده می شوند، تا وقتی که ما با دستور git commit یک commit مشخص از پروژه مان می سازیم، این فایل هایی که در stage بودند، در commit قرار داده شوند. <br> <br> اما stash مرحله ای قبل از stage کردن است. به عبارتی، ممکن است که تغییراتی را در فایل ها داده باشیم که برای commit شدن آماده نیستند، بدین ترتیب با توجه به تعریفی که برای stage شد، می فهمیم که نباید stage کرد. پس چه کنیم؟ اینجاست که stash به کارمان می آید، برای ذخیره سازی فایل هایی که هنوز آماده نیستند برای commit. ممکن است سوال شود که از لحاظ عملی چه فایده ای دارد و چرا ممکن است چنین نیازی پیش آید؟ مطابق با داک گیت، کاربرد stash وقتی است که تصمیم می گیریم از یک شاخه (branch) به یک شاخه ی دیگری حرکت کنیم، اما طبیعتا فایل های شاخه ها متفاوت است و قصد پوش کردن فایل های یک شاخه در شاخه ی دیگر را نداریم. در این حالت، برای از دست ندادن تغییرات روی شاخه ی اولیه (حتی وقتی برای commit شدن نهایی نیستند) می توانیم از stash استفاده کنیم. بعدا هر گاه برگشتیم، می توانیم از دستورات متنوع stash برای بازیابی آنان استفاده کنیم.
<br><br><br><br>
***
6. مفهوم snapshot به چه معناست؟ ارتباط آن با commit چیست؟ (راهنمایی: لینک) <br> <br>  snapshot به معنی نسخه (وضعیت) یک مخزن در یک نقطه‌ی مشخص از زمان است. هنگامی که یک commit در گیت ایجاد می‌کنیم، گیت یکsnapshot  از کل مخزن در آن نقطه از زمان می‌گیرد. این snapshot شامل محتویات تمام فایل‌های موجود در مخزن و همچنین متادیتای مرتبط با آن فایل‌ها، مانند برچسب زمانی (ورژن آن پروژه)، پیام commit و ... است.لذا، در واقع این snapshot ها هستند که توسط کاربران ایجاد شده و به وبسایت گیت push می شوند. به طور دقیق تر، وقتی از دستور git checkout استفاده می کنیم، این snapshot ساخته می شود. با توجه به اینکه گیت یک سیستم version control است، پس در واقع گیت قادر به ساختن، نگه داری و مدیریت snapshot های یک پروژه است. دقت کنید که ما هم وقتی که تغییراتی در پروژه انجام می دهیم که پس از مدتی کار کردن، می خواهیم آن را commit کنیم، یعنی می خواهیم یک نسخه ی مشخص تا تغییرات آن لحظه را داشته باشیم. پس با توجه به این موضوع، می فهمیم که commit خودش یک snapshot در زمان است. با توجه به این ویژگی، می توانیم به عقب برگشته و مشاهده کنیم که commit های قبلی به چه شکل بودند و چه ورژنی از پروژه را داشتند، همچنین می توانیم تغییرات بین snapshot های مختلف را با هم مقایسه کنیم. وقتی کابران این نسخه های لحظه ای از پروژه شان (همان snapshot) را در گیت push می کنند، سایر کاربران هم می توانند آن را pull کنند تا همگی روی نسخه ای یکسان بتوانند کار کنند. بدین ترتیب، تعریف snapshot و ارتباطش با commit را توضیح دادیم. 
<br><br><br><br>
***
7. تفاوت‌های local repository و remote repository چیست؟ <br> <br> Local repository یا به عبارت دیگر، مخزن محلی، می شود نسخه ای از پروژه ی مد نظر ما که در کامیپوتر محلی مان، فایل های اصلی آن موجود است. با فعالیت روی کامپیوتر محلی مان، می توانیم فایل های پروژه را تغییر، حذف، اضافه، ... کنیم و این تغییراتمان را با کمک دستورات کمکی گیت از جمله git add و git commit و ... می توانیم در اینترنت، روی سایت گیت هاب، قرار دهیم. حال، این نسخه ای از پروژه ی ما که در سایت گیت هاب قرار دارد، مخزن دور یا همان Remote repository نام دارد که سایر کاربران می توانند با دانلود یا با کمک دستورات کمکی گیت مثل git push و fork و clone ... کپی آن نسخه را برای خودشان در کامپیوتر محلی خودشان به دست آورند. سپس، خودشان می توانند در local repository خودشان با این پروژه کار کنند. به همین خاطر، کاملا محتمل است که ما پروژه ای را در remote repository قرار داریم و در عین حال در local repository نیز روی این پروژه فعالیت کرده باشیم اما هنوز این نسخه ی محلی تغییراتمان روی remote repository نباشد، در این صورت، باید با git push تغییراتمان را روی remote repository قرار دهیم تا سایر کاربران اینترنت نیز با آخرین تغییرات پروژه ی ما آشنا شوند. بدین ترتیب، تفاوت local repository و remote repository بیان شد.
